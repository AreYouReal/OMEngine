GL_VERTEX_SHADER

#version 300 es
struct Light{
    lowp vec3 direction;
    lowp vec4 position;
};

uniform mat4 uModelViewM;
uniform mat4 uProjectionM;
uniform lowp mat4 uNormalM;
uniform Light uLight;

layout(location = 0) in vec4 aPosition;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec3 aTexCoord;
layout(location = 3) in vec3 aTangent;

out vec3 texCoord;
out vec3 position;
out vec4 lightDirectionTS;
out vec3 spotDirection;

mat3 calculateTBNMatrix(){
    lowp mat3 tbn;
    tbn[2] = normalize(vec3(uNormalM * vec4(aNormal, 1.0)));
    tbn[0] = normalize(vec3(uNormalM * vec4(aTangent, 1.0)));
    tbn[1] = cross(tbn[2], tbn[0]);
    return tbn;
}

void calculateOutVars(lowp mat3 tbn){
    if(uLight.position.w == 0.0){       // Direction light
        lightDirectionTS = vec4(uLight.direction * tbn, 0.0);
    }else{                              // Point/spot light
        vec3 dir =(uLight.position.xyz - position) * tbn;
        lightDirectionTS = vec4(dir, 1.0);
        if(uLight.position.w == 2.0){   // Spot light
            spotDirection = uLight.direction * tbn;
            lightDirectionTS.w = 2.0;
        }
    }
}

void main(){
    position = vec3(uModelViewM * aPosition);
    gl_Position = uProjectionM * vec4(position, 1.0);
    
    lowp mat3 tbn = calculateTBNMatrix();
    calculateOutVars(tbn);
    
    position = -normalize(position * tbn);
    
    texCoord = aTexCoord;
}

GL_FRAGMENT_SHADER

#version 300 es
precision mediump float;

struct Material{
    lowp vec4       ambient;
    lowp vec4       diffuse;
    lowp vec4       specular;
    mediump float   shininess;
};

struct Light{
    lowp vec4 color;
    
    mediump float dst;
    lowp    float linAtten;
    lowp    float quadAtent;
    
    lowp float spotCosCutoff;
    lowp float spotBlend;
};

uniform Material uMaterial;
uniform Light    uLightFS;

uniform mediump sampler2D uSamplerDiffuse;
uniform mediump sampler2D uSamplerBump;

in lowp vec3 texCoord;
in lowp vec3 position;
in lowp vec4 lightDirectionTS;
in lowp vec3 spotDirection;

out vec4 fragColor;

float attenuation(in vec3 direction){
    highp float dist = length(direction);
    lowp float sphere = max((uLightFS.dst - dist)/uLightFS.dst, 0.0);
    if(sphere <= 0.0) return 0.0;
    highp float lamdistsqr = uLightFS.dst * uLightFS.dst;
    lowp float att = uLightFS.dst / (uLightFS.dst + uLightFS.linAtten * dist);
    att *= lamdistsqr / (lamdistsqr + uLightFS.quadAtent * dist * dist);
    att *= sphere;
    return 1.0;
}

vec4 spotLight(in Light light, in highp vec3 direction, in lowp vec3 spotdir){
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    lowp vec3 normal = texture(uSamplerBump, texCoord.xy).rgb * 2.0 - 1.0;
    lowp vec3 nlightdir = normalize(-direction);
    lowp float ndotl = max(dot(normal, nlightdir), 0.0);
    if(ndotl > 0.0){
        lowp float ldots = max(dot(nlightdir, spotdir), 0.0);
        if(ldots > light.spotCosCutoff){
            lowp float ndoth = max(dot(normal, normalize(nlightdir + position)), 0.0);
            lowp float spot = ldots * clamp((ldots - light.spotCosCutoff)/light.spotBlend, 0.0, 1.0);
            finalColor += uMaterial.diffuse * light.color * ndoth * spot;
            finalColor += uMaterial.specular * light.color * pow(ndoth, uMaterial.shininess) * spot;
        }
    }
    return finalColor;
}

vec4 omniLight(in vec4 color, in vec3 direction){
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    lowp vec3 normal = texture(uSamplerBump, texCoord.xy).rgb * 2.0 - 1.0;
    lowp float ndotl = max( dot( normal, normalize(direction)), 0.0 );
    if(ndotl > 0.0){
        float attenuation = attenuation(direction);
        lowp float ndoth = max(dot(normal, normalize(direction - position)), 0.0);
        finalColor += uMaterial.diffuse * color * ndotl * attenuation;
        finalColor += uMaterial.specular * color * pow(ndoth, uMaterial.shininess) * attenuation;
    }
    return finalColor;
}

vec4 directionalLight(in vec4 color, in vec3 direction){
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    lowp vec3 normal = texture(uSamplerBump, texCoord.xy).rgb * 2.0 - 1.0;
    lowp float ndotl = max( dot( normal, normalize(direction)), 0.0 );
    if(ndotl > 0.0){
        lowp float ndoth = max(dot(normal, normalize(direction - position)), 0.0);
        finalColor += uMaterial.diffuse * color * ndotl;
        finalColor += uMaterial.specular * color * pow(ndoth, uMaterial.shininess);
    }
    return finalColor;
}

void main(){
    lowp vec4 finalColor = uMaterial.ambient;
    if(lightDirectionTS.w == 0.0){  // Directional
        finalColor += directionalLight(uLightFS.color, lightDirectionTS.xyz);
    }else if(lightDirectionTS.w == 1.0){ // Point
        finalColor += omniLight(uLightFS.color, lightDirectionTS.xyz);
    }else{ // Spot
        finalColor += spotLight(uLightFS, lightDirectionTS.xyz, spotDirection);
    }
//    finalColor += lightCalculations(lightColor, lightDirectionTS);
//    finalColor += spotLight(uLightFS, lightDirectionTS, spotDirection);
    fragColor = texture(uSamplerDiffuse, texCoord.xy) * finalColor;
}